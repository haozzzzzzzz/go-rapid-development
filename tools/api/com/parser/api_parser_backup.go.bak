package parser

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"runtime/debug"
	"sort"
	"strings"

	"github.com/go-playground/validator"
	"github.com/haozzzzzzzz/go-rapid-development/utils/file"
	"github.com/sirupsen/logrus"
)

func (m *ApiParser) ScanApis2() (apis []*ApiItem, err error) {
	logrus.Info("Scanning api files...")
	defer func() {
		if err == nil {
			logrus.Info("Scan api files completed")
		}
	}()

	apiFileDir, err := filepath.Abs(m.ApiDir)
	if nil != err {
		logrus.Warnf("get absolute file apiFileDir failed. \n%s.", err)
		return
	}

	// api文件夹中所有的文件
	fileNames, err := file.SearchFileNames(m.ApiDir, func(fileInfo os.FileInfo) bool {
		fileName := fileInfo.Name()
		if strings.HasPrefix(fileName, "api_") {
			return true
		}
		return false

	}, true)

	// 服务源文件
	sort.Strings(fileNames)
	for _, fileName := range fileNames {
		fileApis, errParse := ParseApiFiles(apiFileDir, fileName)
		err = errParse
		if nil != err {
			logrus.Errorf("parse api file %q failed. error: %s.", fileName, err)
			return
		}

		apis = append(apis, fileApis...)
	}

	return
}

func ParseApiFile2(
	apiFileDir string,
	fileName string,
) (apis []*ApiItem, err error) {
	defer func() {
		if iRec := recover(); iRec != nil {
			logrus.Errorf("panic %s. file_name: %s", iRec, fileName)
			debug.PrintStack()
		}
	}()

	fileSet := token.NewFileSet()
	astFile, errParse := parser.ParseFile(fileSet, fileName, nil, parser.AllErrors)
	if nil != errParse {
		err = errParse
		logrus.Warnf("parser parse file %q failed. \n%s.", fileName, err)
		return
	}

	// package name
	packageName := astFile.Name.Name

	for objName, obj := range astFile.Scope.Objects {
		valueSpec, ok := obj.Decl.(*ast.ValueSpec)
		if !ok {
			continue
		}

		selectorExpr, ok := valueSpec.Type.(*ast.SelectorExpr)
		if !ok {
			continue
		}

		xIdent, ok := selectorExpr.X.(*ast.Ident)
		if !ok {
			continue
		}

		selIdent := selectorExpr.Sel

		if xIdent.Name != "ginbuilder" && selIdent.Name != "HandleFunc" {
			continue
		}

		apiItem := new(ApiItem)
		apiItem.SourceFile = strings.Replace(fileName, apiFileDir, "", 1)
		apiItem.ApiHandlerFunc = objName
		apiItem.ApiHandlerPackage = packageName

		relativeDir := filepath.Dir(fileName)
		relativePackageDir := strings.Replace(relativeDir, apiFileDir, "", 1)
		if relativePackageDir != "" { // 子目录
			relativePackageDir = strings.Replace(relativePackageDir, "/", "", 1)
			apiItem.RelativePackage = strings.Replace(relativePackageDir, "/", "_", -1)
		}

		for _, value := range valueSpec.Values {
			compositeLit, ok := value.(*ast.CompositeLit)
			if !ok {
				continue
			}

			// compositeLit.Elts
			for _, elt := range compositeLit.Elts {
				keyValueExpr, ok := elt.(*ast.KeyValueExpr)
				if !ok {
					continue
				}

				keyIdent, ok := keyValueExpr.Key.(*ast.Ident)
				if !ok {
					continue
				}

				// property
				valueLit, ok := keyValueExpr.Value.(*ast.BasicLit)
				if ok {
					value := strings.Replace(valueLit.Value, "\"", "", -1)
					switch keyIdent.Name {
					case "HttpMethod":
						switch value {
						case "GET":
						case "POST":
						case "PUT":
						case "PATCH":
						case "HEAD":
						case "OPTIONS":
						case "DELETE":
						case "CONNECT":
						case "TRACE":
						default:
							err = errors.New(fmt.Sprintf("unsupported http method : %s", value))
							logrus.Errorf("mapping unsupported api failed. %s.", err)
							return
						}
						apiItem.HttpMethod = value

					case "RelativePath":
						apiItem.RelativePath = value

					}
				}

				// handle func
				funcLit, ok := keyValueExpr.Value.(*ast.FuncLit)
				if ok {
					switch keyIdent.Name {
					case "Handle":
						funcBody := funcLit.Body
						for _, funcStmt := range funcBody.List {
							switch funcStmt.(type) {
							case *ast.AssignStmt:
								assignStmt := funcStmt.(*ast.AssignStmt)
								lhs := assignStmt.Lhs
								rhs := assignStmt.Rhs

								_ = lhs
								_ = rhs

								for _, expr := range lhs {
									ident, ok := expr.(*ast.Ident)
									if !ok {
										continue
									}

									switch ident.Name {
									case "pathData":
										apiItem.PathData = parseApiStructData(ident)
									case "queryData":
										apiItem.QueryData = parseApiStructData(ident)
									case "postData":
										apiItem.PostData = parseApiStructData(ident)
									case "respData":
										apiItem.RespData = parseApiStructData(ident)
									}
								}

							case *ast.ReturnStmt:

							}

						}
					}
				}

			}
		}

		err = validator.New().Struct(apiItem)
		if nil != err {
			logrus.Errorf("%#v\n invalid", apiItem)
			return
		}

		apis = append(apis, apiItem)
	}

	return
}

// struct 声明
func parseStructTypeSpec(typeSpec *ast.TypeSpec, maxLevel int, curLevel int) (structType *StructType) {
	if curLevel > maxLevel {
		return
	}

	specStructType, ok := typeSpec.Type.(*ast.StructType)
	if !ok {
		return
	}

	structType = NewStructType()
	structType.Name = typeSpec.Name.Name

	structType.Fields = parseStructExpr(specStructType, maxLevel, curLevel)
	return
}

func parseStructExpr(specStructType *ast.StructType, maxLevel int, curLevel int) (fields []*Field) {
	fields = make([]*Field, 0)
	//fmt.Printf("parse_struct_types:%s  max_level: %d cur_level: %d\n", structType.Name, maxLevel, curLevel)
	for _, field := range specStructType.Fields.List {
		exprFieldType := convertExpr(field.Type)

		if field.Names == nil { // 复用了其他struct
			fieldParent := exprFieldType.(*ast.Ident).Obj
			parentStruct := parseStructTypeSpec(fieldParent.Decl.(*ast.TypeSpec), maxLevel, curLevel+1)
			if parentStruct != nil {
				for _, pField := range parentStruct.Fields {
					fields = append(fields, pField)
				}
			}

		} else {

			//&ast.Field{Doc:(*ast.CommentGroup)(nil), Names:[]*ast.Ident{(*ast.Ident)(0xc4202b21e0)}, Type:(*ast.Ident)(0xc4202b2200), Tag:(*ast.BasicLit)(0xc4202b2220), Comment:(*ast.CommentGroup)(nil)}
			structField := NewField()
			structField.Name = field.Names[0].Name

			tagValue := strings.Replace(field.Tag.Value, "`", "", -1)
			strPairs := strings.Split(tagValue, " ")
			for _, pair := range strPairs {
				pair = strings.Replace(pair, "\"", "", -1)
				tagPair := strings.Split(pair, ":")
				structField.Tags[tagPair[0]] = tagPair[1]
			}

			iType := parseTypeSpec(exprFieldType, maxLevel, curLevel+1)
			structField.TypeName = iType.TypeName()
			structField.TypeSpec = iType

			fields = append(fields, structField)
		}

	}

	return
}

func convertExpr(expr ast.Expr) (newExpr ast.Expr) {
	switch expr.(type) {
	case *ast.StarExpr:
		newExpr = expr.(*ast.StarExpr).X

	case *ast.SelectorExpr:
		newExpr = expr.(*ast.SelectorExpr).Sel

	default:
		newExpr = expr

	}

	return
}

// iType 一定不为nil，即使不向下递归也要返回Name
func parseTypeSpec(typeExpr ast.Expr, maxLevel int, curLevel int) (iType IType) {
	fmt.Printf("parse_type_spec:%#v max_level:%d cur_level:%d\n", typeExpr, maxLevel, curLevel)

	typeExpr = convertExpr(typeExpr) // 转换为引用类型

	iType = NewStandardType("Unsupported")

	switch typeExpr.(type) {
	case *ast.Ident:
		ident := typeExpr.(*ast.Ident)

		if ident.Obj != nil { // 页面内定义的类型
			structType := NewStructType()
			structType.Name = ident.Name
			if curLevel <= maxLevel {
				parsed := parseStructTypeSpec(ident.Obj.Decl.(*ast.TypeSpec), maxLevel, curLevel)
				if parsed != nil {
					structType = parsed
				}
			}

			iType = structType
		}

		if ident.Obj == nil { // 标准基本类型 int、string等
			standType := NewStandardType(ident.Name)
			iType = standType

		} else { // 其他包定义的struct

		}

	case *ast.StructType: // 匿名struct type
		exprStructType := typeExpr.(*ast.StructType)
		structType := NewStructType()
		if curLevel <= maxLevel {
			structType.Fields = parseStructExpr(exprStructType, maxLevel, curLevel)
		}

		iType = structType

	case *ast.MapType:
		exprMapType := typeExpr.(*ast.MapType)
		keyName := exprMapType.Key.(*ast.Ident).Name
		mapType := NewMapType()
		mapType.Key = keyName

		exprValue := convertExpr(exprMapType.Value)

		if curLevel <= maxLevel {
			valueType := parseTypeSpec(exprMapType.Value, maxLevel, curLevel)
			mapType.ValueSpec = valueType
			mapType.Name = fmt.Sprintf("map[%s]%s", mapType.Key, valueType.TypeName())

		} else {
			value := "interface{}"
			switch exprValue.(type) {
			case *ast.Ident:
				value = exprValue.(*ast.Ident).Name
			default:
				// 如果value的type为map，则设为interface
			}

			mapType.Name = fmt.Sprintf("map[%s]%s", mapType.Key, value)

		}

		iType = mapType

	case *ast.ArrayType:
		exprArrType := typeExpr.(*ast.ArrayType)
		exprArrElt := convertExpr(exprArrType.Elt) // 数组元素类型
		arrType := NewArrayType()

		if curLevel <= maxLevel {
			eltType := parseTypeSpec(exprArrElt, maxLevel, curLevel)
			arrType.EltSpec = eltType
			arrType.EltName = eltType.TypeName()

		} else {
			switch exprArrElt.(type) {
			case *ast.Ident:
				arrType.EltName = exprArrElt.(*ast.Ident).Name
			}
		}

		arrType.Name = fmt.Sprintf("[]%s", arrType.EltName)

		iType = arrType

	case *ast.InterfaceType:
		iType = NewInterfaceType()

	default:
		fmt.Printf("parse_type_sepc unsupported %#v\n", typeExpr)

	}

	return
}

// TODO
func parseApiStructData(ident *ast.Ident) (structData *StructType) {
	structData = &StructType{
		Name: ident.Name,
	}

	decl := ident.Obj.Decl
	declStmt, ok := decl.(*ast.AssignStmt)
	if !ok {
		return
	}

	// 指针
	var compositeLit *ast.CompositeLit
	expr := declStmt.Rhs[0]
	pointerExpr, ok := expr.(*ast.UnaryExpr)
	if ok {
		expr = pointerExpr.X
	}

	// 非指针
	compositeLit, ok = expr.(*ast.CompositeLit)
	if !ok {
		return
	}

	comIdent, ok := compositeLit.Type.(*ast.Ident)
	if !ok {
		// TODO 报错 service/src/service/VideoBuddyConfigApi/manage/api/config/api_config_conditiongroupattachment.go
		structData = NewStructType()
		structData.Name = "UNSUPPORTED"
		return
	}

	typeSpec := comIdent.Obj.Decl.(*ast.TypeSpec)
	structData = parseStructTypeSpec(typeSpec, 3, 1) // api层次最多3层，避免无穷递归
	return
}
